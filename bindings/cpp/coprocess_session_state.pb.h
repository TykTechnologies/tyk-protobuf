// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: coprocess_session_state.proto

#ifndef PROTOBUF_INCLUDED_coprocess_5fsession_5fstate_2eproto
#define PROTOBUF_INCLUDED_coprocess_5fsession_5fstate_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_coprocess_5fsession_5fstate_2eproto 

namespace protobuf_coprocess_5fsession_5fstate_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_coprocess_5fsession_5fstate_2eproto
namespace coprocess {
class AccessDefinition;
class AccessDefinitionDefaultTypeInternal;
extern AccessDefinitionDefaultTypeInternal _AccessDefinition_default_instance_;
class AccessSpec;
class AccessSpecDefaultTypeInternal;
extern AccessSpecDefaultTypeInternal _AccessSpec_default_instance_;
class BasicAuthData;
class BasicAuthDataDefaultTypeInternal;
extern BasicAuthDataDefaultTypeInternal _BasicAuthData_default_instance_;
class JWTData;
class JWTDataDefaultTypeInternal;
extern JWTDataDefaultTypeInternal _JWTData_default_instance_;
class Monitor;
class MonitorDefaultTypeInternal;
extern MonitorDefaultTypeInternal _Monitor_default_instance_;
class SessionState;
class SessionStateDefaultTypeInternal;
extern SessionStateDefaultTypeInternal _SessionState_default_instance_;
class SessionState_AccessRightsEntry_DoNotUse;
class SessionState_AccessRightsEntry_DoNotUseDefaultTypeInternal;
extern SessionState_AccessRightsEntry_DoNotUseDefaultTypeInternal _SessionState_AccessRightsEntry_DoNotUse_default_instance_;
class SessionState_OauthKeysEntry_DoNotUse;
class SessionState_OauthKeysEntry_DoNotUseDefaultTypeInternal;
extern SessionState_OauthKeysEntry_DoNotUseDefaultTypeInternal _SessionState_OauthKeysEntry_DoNotUse_default_instance_;
}  // namespace coprocess
namespace google {
namespace protobuf {
template<> ::coprocess::AccessDefinition* Arena::CreateMaybeMessage<::coprocess::AccessDefinition>(Arena*);
template<> ::coprocess::AccessSpec* Arena::CreateMaybeMessage<::coprocess::AccessSpec>(Arena*);
template<> ::coprocess::BasicAuthData* Arena::CreateMaybeMessage<::coprocess::BasicAuthData>(Arena*);
template<> ::coprocess::JWTData* Arena::CreateMaybeMessage<::coprocess::JWTData>(Arena*);
template<> ::coprocess::Monitor* Arena::CreateMaybeMessage<::coprocess::Monitor>(Arena*);
template<> ::coprocess::SessionState* Arena::CreateMaybeMessage<::coprocess::SessionState>(Arena*);
template<> ::coprocess::SessionState_AccessRightsEntry_DoNotUse* Arena::CreateMaybeMessage<::coprocess::SessionState_AccessRightsEntry_DoNotUse>(Arena*);
template<> ::coprocess::SessionState_OauthKeysEntry_DoNotUse* Arena::CreateMaybeMessage<::coprocess::SessionState_OauthKeysEntry_DoNotUse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace coprocess {

// ===================================================================

class AccessSpec : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:coprocess.AccessSpec) */ {
 public:
  AccessSpec();
  virtual ~AccessSpec();

  AccessSpec(const AccessSpec& from);

  inline AccessSpec& operator=(const AccessSpec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessSpec(AccessSpec&& from) noexcept
    : AccessSpec() {
    *this = ::std::move(from);
  }

  inline AccessSpec& operator=(AccessSpec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessSpec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessSpec* internal_default_instance() {
    return reinterpret_cast<const AccessSpec*>(
               &_AccessSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(AccessSpec* other);
  friend void swap(AccessSpec& a, AccessSpec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessSpec* New() const final {
    return CreateMaybeMessage<AccessSpec>(NULL);
  }

  AccessSpec* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccessSpec>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccessSpec& from);
  void MergeFrom(const AccessSpec& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string methods = 2;
  int methods_size() const;
  void clear_methods();
  static const int kMethodsFieldNumber = 2;
  const ::std::string& methods(int index) const;
  ::std::string* mutable_methods(int index);
  void set_methods(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_methods(int index, ::std::string&& value);
  #endif
  void set_methods(int index, const char* value);
  void set_methods(int index, const char* value, size_t size);
  ::std::string* add_methods();
  void add_methods(const ::std::string& value);
  #if LANG_CXX11
  void add_methods(::std::string&& value);
  #endif
  void add_methods(const char* value);
  void add_methods(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& methods() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_methods();

  // string url = 1;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:coprocess.AccessSpec)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> methods_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_coprocess_5fsession_5fstate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccessDefinition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:coprocess.AccessDefinition) */ {
 public:
  AccessDefinition();
  virtual ~AccessDefinition();

  AccessDefinition(const AccessDefinition& from);

  inline AccessDefinition& operator=(const AccessDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessDefinition(AccessDefinition&& from) noexcept
    : AccessDefinition() {
    *this = ::std::move(from);
  }

  inline AccessDefinition& operator=(AccessDefinition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessDefinition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessDefinition* internal_default_instance() {
    return reinterpret_cast<const AccessDefinition*>(
               &_AccessDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(AccessDefinition* other);
  friend void swap(AccessDefinition& a, AccessDefinition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessDefinition* New() const final {
    return CreateMaybeMessage<AccessDefinition>(NULL);
  }

  AccessDefinition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccessDefinition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccessDefinition& from);
  void MergeFrom(const AccessDefinition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessDefinition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string versions = 3;
  int versions_size() const;
  void clear_versions();
  static const int kVersionsFieldNumber = 3;
  const ::std::string& versions(int index) const;
  ::std::string* mutable_versions(int index);
  void set_versions(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_versions(int index, ::std::string&& value);
  #endif
  void set_versions(int index, const char* value);
  void set_versions(int index, const char* value, size_t size);
  ::std::string* add_versions();
  void add_versions(const ::std::string& value);
  #if LANG_CXX11
  void add_versions(::std::string&& value);
  #endif
  void add_versions(const char* value);
  void add_versions(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& versions() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_versions();

  // repeated .coprocess.AccessSpec allowed_urls = 4;
  int allowed_urls_size() const;
  void clear_allowed_urls();
  static const int kAllowedUrlsFieldNumber = 4;
  ::coprocess::AccessSpec* mutable_allowed_urls(int index);
  ::google::protobuf::RepeatedPtrField< ::coprocess::AccessSpec >*
      mutable_allowed_urls();
  const ::coprocess::AccessSpec& allowed_urls(int index) const;
  ::coprocess::AccessSpec* add_allowed_urls();
  const ::google::protobuf::RepeatedPtrField< ::coprocess::AccessSpec >&
      allowed_urls() const;

  // string api_name = 1;
  void clear_api_name();
  static const int kApiNameFieldNumber = 1;
  const ::std::string& api_name() const;
  void set_api_name(const ::std::string& value);
  #if LANG_CXX11
  void set_api_name(::std::string&& value);
  #endif
  void set_api_name(const char* value);
  void set_api_name(const char* value, size_t size);
  ::std::string* mutable_api_name();
  ::std::string* release_api_name();
  void set_allocated_api_name(::std::string* api_name);

  // string api_id = 2;
  void clear_api_id();
  static const int kApiIdFieldNumber = 2;
  const ::std::string& api_id() const;
  void set_api_id(const ::std::string& value);
  #if LANG_CXX11
  void set_api_id(::std::string&& value);
  #endif
  void set_api_id(const char* value);
  void set_api_id(const char* value, size_t size);
  ::std::string* mutable_api_id();
  ::std::string* release_api_id();
  void set_allocated_api_id(::std::string* api_id);

  // @@protoc_insertion_point(class_scope:coprocess.AccessDefinition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> versions_;
  ::google::protobuf::RepeatedPtrField< ::coprocess::AccessSpec > allowed_urls_;
  ::google::protobuf::internal::ArenaStringPtr api_name_;
  ::google::protobuf::internal::ArenaStringPtr api_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_coprocess_5fsession_5fstate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BasicAuthData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:coprocess.BasicAuthData) */ {
 public:
  BasicAuthData();
  virtual ~BasicAuthData();

  BasicAuthData(const BasicAuthData& from);

  inline BasicAuthData& operator=(const BasicAuthData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BasicAuthData(BasicAuthData&& from) noexcept
    : BasicAuthData() {
    *this = ::std::move(from);
  }

  inline BasicAuthData& operator=(BasicAuthData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BasicAuthData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BasicAuthData* internal_default_instance() {
    return reinterpret_cast<const BasicAuthData*>(
               &_BasicAuthData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(BasicAuthData* other);
  friend void swap(BasicAuthData& a, BasicAuthData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BasicAuthData* New() const final {
    return CreateMaybeMessage<BasicAuthData>(NULL);
  }

  BasicAuthData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BasicAuthData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BasicAuthData& from);
  void MergeFrom(const BasicAuthData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BasicAuthData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string password = 1;
  void clear_password();
  static const int kPasswordFieldNumber = 1;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // string hash = 2;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:coprocess.BasicAuthData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_coprocess_5fsession_5fstate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JWTData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:coprocess.JWTData) */ {
 public:
  JWTData();
  virtual ~JWTData();

  JWTData(const JWTData& from);

  inline JWTData& operator=(const JWTData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JWTData(JWTData&& from) noexcept
    : JWTData() {
    *this = ::std::move(from);
  }

  inline JWTData& operator=(JWTData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JWTData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JWTData* internal_default_instance() {
    return reinterpret_cast<const JWTData*>(
               &_JWTData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(JWTData* other);
  friend void swap(JWTData& a, JWTData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JWTData* New() const final {
    return CreateMaybeMessage<JWTData>(NULL);
  }

  JWTData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JWTData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JWTData& from);
  void MergeFrom(const JWTData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JWTData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string secret = 1;
  void clear_secret();
  static const int kSecretFieldNumber = 1;
  const ::std::string& secret() const;
  void set_secret(const ::std::string& value);
  #if LANG_CXX11
  void set_secret(::std::string&& value);
  #endif
  void set_secret(const char* value);
  void set_secret(const char* value, size_t size);
  ::std::string* mutable_secret();
  ::std::string* release_secret();
  void set_allocated_secret(::std::string* secret);

  // @@protoc_insertion_point(class_scope:coprocess.JWTData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr secret_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_coprocess_5fsession_5fstate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Monitor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:coprocess.Monitor) */ {
 public:
  Monitor();
  virtual ~Monitor();

  Monitor(const Monitor& from);

  inline Monitor& operator=(const Monitor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Monitor(Monitor&& from) noexcept
    : Monitor() {
    *this = ::std::move(from);
  }

  inline Monitor& operator=(Monitor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Monitor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Monitor* internal_default_instance() {
    return reinterpret_cast<const Monitor*>(
               &_Monitor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Monitor* other);
  friend void swap(Monitor& a, Monitor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Monitor* New() const final {
    return CreateMaybeMessage<Monitor>(NULL);
  }

  Monitor* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Monitor>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Monitor& from);
  void MergeFrom(const Monitor& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Monitor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double trigger_limits = 1;
  int trigger_limits_size() const;
  void clear_trigger_limits();
  static const int kTriggerLimitsFieldNumber = 1;
  double trigger_limits(int index) const;
  void set_trigger_limits(int index, double value);
  void add_trigger_limits(double value);
  const ::google::protobuf::RepeatedField< double >&
      trigger_limits() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_trigger_limits();

  // @@protoc_insertion_point(class_scope:coprocess.Monitor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > trigger_limits_;
  mutable int _trigger_limits_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_coprocess_5fsession_5fstate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SessionState_AccessRightsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<SessionState_AccessRightsEntry_DoNotUse, 
    ::std::string, ::coprocess::AccessDefinition,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<SessionState_AccessRightsEntry_DoNotUse, 
    ::std::string, ::coprocess::AccessDefinition,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  SessionState_AccessRightsEntry_DoNotUse();
  SessionState_AccessRightsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const SessionState_AccessRightsEntry_DoNotUse& other);
  static const SessionState_AccessRightsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SessionState_AccessRightsEntry_DoNotUse*>(&_SessionState_AccessRightsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class SessionState_OauthKeysEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<SessionState_OauthKeysEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<SessionState_OauthKeysEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  SessionState_OauthKeysEntry_DoNotUse();
  SessionState_OauthKeysEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const SessionState_OauthKeysEntry_DoNotUse& other);
  static const SessionState_OauthKeysEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SessionState_OauthKeysEntry_DoNotUse*>(&_SessionState_OauthKeysEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class SessionState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:coprocess.SessionState) */ {
 public:
  SessionState();
  virtual ~SessionState();

  SessionState(const SessionState& from);

  inline SessionState& operator=(const SessionState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SessionState(SessionState&& from) noexcept
    : SessionState() {
    *this = ::std::move(from);
  }

  inline SessionState& operator=(SessionState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionState* internal_default_instance() {
    return reinterpret_cast<const SessionState*>(
               &_SessionState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(SessionState* other);
  friend void swap(SessionState& a, SessionState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SessionState* New() const final {
    return CreateMaybeMessage<SessionState>(NULL);
  }

  SessionState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SessionState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SessionState& from);
  void MergeFrom(const SessionState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .coprocess.AccessDefinition> access_rights = 10;
  int access_rights_size() const;
  void clear_access_rights();
  static const int kAccessRightsFieldNumber = 10;
  const ::google::protobuf::Map< ::std::string, ::coprocess::AccessDefinition >&
      access_rights() const;
  ::google::protobuf::Map< ::std::string, ::coprocess::AccessDefinition >*
      mutable_access_rights();

  // map<string, string> oauth_keys = 13;
  int oauth_keys_size() const;
  void clear_oauth_keys();
  static const int kOauthKeysFieldNumber = 13;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      oauth_keys() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_oauth_keys();

  // repeated string tags = 24;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 24;
  const ::std::string& tags(int index) const;
  ::std::string* mutable_tags(int index);
  void set_tags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tags(int index, ::std::string&& value);
  #endif
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  ::std::string* add_tags();
  void add_tags(const ::std::string& value);
  #if LANG_CXX11
  void add_tags(::std::string&& value);
  #endif
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // string org_id = 11;
  void clear_org_id();
  static const int kOrgIdFieldNumber = 11;
  const ::std::string& org_id() const;
  void set_org_id(const ::std::string& value);
  #if LANG_CXX11
  void set_org_id(::std::string&& value);
  #endif
  void set_org_id(const char* value);
  void set_org_id(const char* value, size_t size);
  ::std::string* mutable_org_id();
  ::std::string* release_org_id();
  void set_allocated_org_id(::std::string* org_id);

  // string oauth_client_id = 12;
  void clear_oauth_client_id();
  static const int kOauthClientIdFieldNumber = 12;
  const ::std::string& oauth_client_id() const;
  void set_oauth_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_oauth_client_id(::std::string&& value);
  #endif
  void set_oauth_client_id(const char* value);
  void set_oauth_client_id(const char* value, size_t size);
  ::std::string* mutable_oauth_client_id();
  ::std::string* release_oauth_client_id();
  void set_allocated_oauth_client_id(::std::string* oauth_client_id);

  // string hmac_secret = 17;
  void clear_hmac_secret();
  static const int kHmacSecretFieldNumber = 17;
  const ::std::string& hmac_secret() const;
  void set_hmac_secret(const ::std::string& value);
  #if LANG_CXX11
  void set_hmac_secret(::std::string&& value);
  #endif
  void set_hmac_secret(const char* value);
  void set_hmac_secret(const char* value, size_t size);
  ::std::string* mutable_hmac_secret();
  ::std::string* release_hmac_secret();
  void set_allocated_hmac_secret(::std::string* hmac_secret);

  // string apply_policy_id = 19;
  void clear_apply_policy_id();
  static const int kApplyPolicyIdFieldNumber = 19;
  const ::std::string& apply_policy_id() const;
  void set_apply_policy_id(const ::std::string& value);
  #if LANG_CXX11
  void set_apply_policy_id(::std::string&& value);
  #endif
  void set_apply_policy_id(const char* value);
  void set_apply_policy_id(const char* value, size_t size);
  ::std::string* mutable_apply_policy_id();
  ::std::string* release_apply_policy_id();
  void set_allocated_apply_policy_id(::std::string* apply_policy_id);

  // string metadata = 23;
  void clear_metadata();
  static const int kMetadataFieldNumber = 23;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  #if LANG_CXX11
  void set_metadata(::std::string&& value);
  #endif
  void set_metadata(const char* value);
  void set_metadata(const char* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // string alias = 25;
  void clear_alias();
  static const int kAliasFieldNumber = 25;
  const ::std::string& alias() const;
  void set_alias(const ::std::string& value);
  #if LANG_CXX11
  void set_alias(::std::string&& value);
  #endif
  void set_alias(const char* value);
  void set_alias(const char* value, size_t size);
  ::std::string* mutable_alias();
  ::std::string* release_alias();
  void set_allocated_alias(::std::string* alias);

  // string last_updated = 26;
  void clear_last_updated();
  static const int kLastUpdatedFieldNumber = 26;
  const ::std::string& last_updated() const;
  void set_last_updated(const ::std::string& value);
  #if LANG_CXX11
  void set_last_updated(::std::string&& value);
  #endif
  void set_last_updated(const char* value);
  void set_last_updated(const char* value, size_t size);
  ::std::string* mutable_last_updated();
  ::std::string* release_last_updated();
  void set_allocated_last_updated(::std::string* last_updated);

  // .coprocess.BasicAuthData basic_auth_data = 14;
  bool has_basic_auth_data() const;
  void clear_basic_auth_data();
  static const int kBasicAuthDataFieldNumber = 14;
  private:
  const ::coprocess::BasicAuthData& _internal_basic_auth_data() const;
  public:
  const ::coprocess::BasicAuthData& basic_auth_data() const;
  ::coprocess::BasicAuthData* release_basic_auth_data();
  ::coprocess::BasicAuthData* mutable_basic_auth_data();
  void set_allocated_basic_auth_data(::coprocess::BasicAuthData* basic_auth_data);

  // .coprocess.JWTData jwt_data = 15;
  bool has_jwt_data() const;
  void clear_jwt_data();
  static const int kJwtDataFieldNumber = 15;
  private:
  const ::coprocess::JWTData& _internal_jwt_data() const;
  public:
  const ::coprocess::JWTData& jwt_data() const;
  ::coprocess::JWTData* release_jwt_data();
  ::coprocess::JWTData* mutable_jwt_data();
  void set_allocated_jwt_data(::coprocess::JWTData* jwt_data);

  // .coprocess.Monitor monitor = 21;
  bool has_monitor() const;
  void clear_monitor();
  static const int kMonitorFieldNumber = 21;
  private:
  const ::coprocess::Monitor& _internal_monitor() const;
  public:
  const ::coprocess::Monitor& monitor() const;
  ::coprocess::Monitor* release_monitor();
  ::coprocess::Monitor* mutable_monitor();
  void set_allocated_monitor(::coprocess::Monitor* monitor);

  // int64 last_check = 1;
  void clear_last_check();
  static const int kLastCheckFieldNumber = 1;
  ::google::protobuf::int64 last_check() const;
  void set_last_check(::google::protobuf::int64 value);

  // double allowance = 2;
  void clear_allowance();
  static const int kAllowanceFieldNumber = 2;
  double allowance() const;
  void set_allowance(double value);

  // double rate = 3;
  void clear_rate();
  static const int kRateFieldNumber = 3;
  double rate() const;
  void set_rate(double value);

  // double per = 4;
  void clear_per();
  static const int kPerFieldNumber = 4;
  double per() const;
  void set_per(double value);

  // int64 expires = 5;
  void clear_expires();
  static const int kExpiresFieldNumber = 5;
  ::google::protobuf::int64 expires() const;
  void set_expires(::google::protobuf::int64 value);

  // int64 quota_max = 6;
  void clear_quota_max();
  static const int kQuotaMaxFieldNumber = 6;
  ::google::protobuf::int64 quota_max() const;
  void set_quota_max(::google::protobuf::int64 value);

  // int64 quota_renews = 7;
  void clear_quota_renews();
  static const int kQuotaRenewsFieldNumber = 7;
  ::google::protobuf::int64 quota_renews() const;
  void set_quota_renews(::google::protobuf::int64 value);

  // int64 quota_remaining = 8;
  void clear_quota_remaining();
  static const int kQuotaRemainingFieldNumber = 8;
  ::google::protobuf::int64 quota_remaining() const;
  void set_quota_remaining(::google::protobuf::int64 value);

  // int64 quota_renewal_rate = 9;
  void clear_quota_renewal_rate();
  static const int kQuotaRenewalRateFieldNumber = 9;
  ::google::protobuf::int64 quota_renewal_rate() const;
  void set_quota_renewal_rate(::google::protobuf::int64 value);

  // int64 data_expires = 20;
  void clear_data_expires();
  static const int kDataExpiresFieldNumber = 20;
  ::google::protobuf::int64 data_expires() const;
  void set_data_expires(::google::protobuf::int64 value);

  // int64 id_extractor_deadline = 27;
  void clear_id_extractor_deadline();
  static const int kIdExtractorDeadlineFieldNumber = 27;
  ::google::protobuf::int64 id_extractor_deadline() const;
  void set_id_extractor_deadline(::google::protobuf::int64 value);

  // int64 session_lifetime = 28;
  void clear_session_lifetime();
  static const int kSessionLifetimeFieldNumber = 28;
  ::google::protobuf::int64 session_lifetime() const;
  void set_session_lifetime(::google::protobuf::int64 value);

  // bool hmac_enabled = 16;
  void clear_hmac_enabled();
  static const int kHmacEnabledFieldNumber = 16;
  bool hmac_enabled() const;
  void set_hmac_enabled(bool value);

  // bool is_inactive = 18;
  void clear_is_inactive();
  static const int kIsInactiveFieldNumber = 18;
  bool is_inactive() const;
  void set_is_inactive(bool value);

  // bool enable_detailed_recording = 22;
  void clear_enable_detailed_recording();
  static const int kEnableDetailedRecordingFieldNumber = 22;
  bool enable_detailed_recording() const;
  void set_enable_detailed_recording(bool value);

  // @@protoc_insertion_point(class_scope:coprocess.SessionState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      SessionState_AccessRightsEntry_DoNotUse,
      ::std::string, ::coprocess::AccessDefinition,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > access_rights_;
  ::google::protobuf::internal::MapField<
      SessionState_OauthKeysEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > oauth_keys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  ::google::protobuf::internal::ArenaStringPtr org_id_;
  ::google::protobuf::internal::ArenaStringPtr oauth_client_id_;
  ::google::protobuf::internal::ArenaStringPtr hmac_secret_;
  ::google::protobuf::internal::ArenaStringPtr apply_policy_id_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  ::google::protobuf::internal::ArenaStringPtr alias_;
  ::google::protobuf::internal::ArenaStringPtr last_updated_;
  ::coprocess::BasicAuthData* basic_auth_data_;
  ::coprocess::JWTData* jwt_data_;
  ::coprocess::Monitor* monitor_;
  ::google::protobuf::int64 last_check_;
  double allowance_;
  double rate_;
  double per_;
  ::google::protobuf::int64 expires_;
  ::google::protobuf::int64 quota_max_;
  ::google::protobuf::int64 quota_renews_;
  ::google::protobuf::int64 quota_remaining_;
  ::google::protobuf::int64 quota_renewal_rate_;
  ::google::protobuf::int64 data_expires_;
  ::google::protobuf::int64 id_extractor_deadline_;
  ::google::protobuf::int64 session_lifetime_;
  bool hmac_enabled_;
  bool is_inactive_;
  bool enable_detailed_recording_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_coprocess_5fsession_5fstate_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AccessSpec

// string url = 1;
inline void AccessSpec::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccessSpec::url() const {
  // @@protoc_insertion_point(field_get:coprocess.AccessSpec.url)
  return url_.GetNoArena();
}
inline void AccessSpec::set_url(const ::std::string& value) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:coprocess.AccessSpec.url)
}
#if LANG_CXX11
inline void AccessSpec::set_url(::std::string&& value) {
  
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:coprocess.AccessSpec.url)
}
#endif
inline void AccessSpec::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:coprocess.AccessSpec.url)
}
inline void AccessSpec::set_url(const char* value, size_t size) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:coprocess.AccessSpec.url)
}
inline ::std::string* AccessSpec::mutable_url() {
  
  // @@protoc_insertion_point(field_mutable:coprocess.AccessSpec.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccessSpec::release_url() {
  // @@protoc_insertion_point(field_release:coprocess.AccessSpec.url)
  
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccessSpec::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:coprocess.AccessSpec.url)
}

// repeated string methods = 2;
inline int AccessSpec::methods_size() const {
  return methods_.size();
}
inline void AccessSpec::clear_methods() {
  methods_.Clear();
}
inline const ::std::string& AccessSpec::methods(int index) const {
  // @@protoc_insertion_point(field_get:coprocess.AccessSpec.methods)
  return methods_.Get(index);
}
inline ::std::string* AccessSpec::mutable_methods(int index) {
  // @@protoc_insertion_point(field_mutable:coprocess.AccessSpec.methods)
  return methods_.Mutable(index);
}
inline void AccessSpec::set_methods(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:coprocess.AccessSpec.methods)
  methods_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AccessSpec::set_methods(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:coprocess.AccessSpec.methods)
  methods_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AccessSpec::set_methods(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  methods_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:coprocess.AccessSpec.methods)
}
inline void AccessSpec::set_methods(int index, const char* value, size_t size) {
  methods_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:coprocess.AccessSpec.methods)
}
inline ::std::string* AccessSpec::add_methods() {
  // @@protoc_insertion_point(field_add_mutable:coprocess.AccessSpec.methods)
  return methods_.Add();
}
inline void AccessSpec::add_methods(const ::std::string& value) {
  methods_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:coprocess.AccessSpec.methods)
}
#if LANG_CXX11
inline void AccessSpec::add_methods(::std::string&& value) {
  methods_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:coprocess.AccessSpec.methods)
}
#endif
inline void AccessSpec::add_methods(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  methods_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:coprocess.AccessSpec.methods)
}
inline void AccessSpec::add_methods(const char* value, size_t size) {
  methods_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:coprocess.AccessSpec.methods)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AccessSpec::methods() const {
  // @@protoc_insertion_point(field_list:coprocess.AccessSpec.methods)
  return methods_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AccessSpec::mutable_methods() {
  // @@protoc_insertion_point(field_mutable_list:coprocess.AccessSpec.methods)
  return &methods_;
}

// -------------------------------------------------------------------

// AccessDefinition

// string api_name = 1;
inline void AccessDefinition::clear_api_name() {
  api_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccessDefinition::api_name() const {
  // @@protoc_insertion_point(field_get:coprocess.AccessDefinition.api_name)
  return api_name_.GetNoArena();
}
inline void AccessDefinition::set_api_name(const ::std::string& value) {
  
  api_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:coprocess.AccessDefinition.api_name)
}
#if LANG_CXX11
inline void AccessDefinition::set_api_name(::std::string&& value) {
  
  api_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:coprocess.AccessDefinition.api_name)
}
#endif
inline void AccessDefinition::set_api_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  api_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:coprocess.AccessDefinition.api_name)
}
inline void AccessDefinition::set_api_name(const char* value, size_t size) {
  
  api_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:coprocess.AccessDefinition.api_name)
}
inline ::std::string* AccessDefinition::mutable_api_name() {
  
  // @@protoc_insertion_point(field_mutable:coprocess.AccessDefinition.api_name)
  return api_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccessDefinition::release_api_name() {
  // @@protoc_insertion_point(field_release:coprocess.AccessDefinition.api_name)
  
  return api_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccessDefinition::set_allocated_api_name(::std::string* api_name) {
  if (api_name != NULL) {
    
  } else {
    
  }
  api_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), api_name);
  // @@protoc_insertion_point(field_set_allocated:coprocess.AccessDefinition.api_name)
}

// string api_id = 2;
inline void AccessDefinition::clear_api_id() {
  api_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccessDefinition::api_id() const {
  // @@protoc_insertion_point(field_get:coprocess.AccessDefinition.api_id)
  return api_id_.GetNoArena();
}
inline void AccessDefinition::set_api_id(const ::std::string& value) {
  
  api_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:coprocess.AccessDefinition.api_id)
}
#if LANG_CXX11
inline void AccessDefinition::set_api_id(::std::string&& value) {
  
  api_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:coprocess.AccessDefinition.api_id)
}
#endif
inline void AccessDefinition::set_api_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  api_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:coprocess.AccessDefinition.api_id)
}
inline void AccessDefinition::set_api_id(const char* value, size_t size) {
  
  api_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:coprocess.AccessDefinition.api_id)
}
inline ::std::string* AccessDefinition::mutable_api_id() {
  
  // @@protoc_insertion_point(field_mutable:coprocess.AccessDefinition.api_id)
  return api_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccessDefinition::release_api_id() {
  // @@protoc_insertion_point(field_release:coprocess.AccessDefinition.api_id)
  
  return api_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccessDefinition::set_allocated_api_id(::std::string* api_id) {
  if (api_id != NULL) {
    
  } else {
    
  }
  api_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), api_id);
  // @@protoc_insertion_point(field_set_allocated:coprocess.AccessDefinition.api_id)
}

// repeated string versions = 3;
inline int AccessDefinition::versions_size() const {
  return versions_.size();
}
inline void AccessDefinition::clear_versions() {
  versions_.Clear();
}
inline const ::std::string& AccessDefinition::versions(int index) const {
  // @@protoc_insertion_point(field_get:coprocess.AccessDefinition.versions)
  return versions_.Get(index);
}
inline ::std::string* AccessDefinition::mutable_versions(int index) {
  // @@protoc_insertion_point(field_mutable:coprocess.AccessDefinition.versions)
  return versions_.Mutable(index);
}
inline void AccessDefinition::set_versions(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:coprocess.AccessDefinition.versions)
  versions_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AccessDefinition::set_versions(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:coprocess.AccessDefinition.versions)
  versions_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AccessDefinition::set_versions(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  versions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:coprocess.AccessDefinition.versions)
}
inline void AccessDefinition::set_versions(int index, const char* value, size_t size) {
  versions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:coprocess.AccessDefinition.versions)
}
inline ::std::string* AccessDefinition::add_versions() {
  // @@protoc_insertion_point(field_add_mutable:coprocess.AccessDefinition.versions)
  return versions_.Add();
}
inline void AccessDefinition::add_versions(const ::std::string& value) {
  versions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:coprocess.AccessDefinition.versions)
}
#if LANG_CXX11
inline void AccessDefinition::add_versions(::std::string&& value) {
  versions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:coprocess.AccessDefinition.versions)
}
#endif
inline void AccessDefinition::add_versions(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  versions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:coprocess.AccessDefinition.versions)
}
inline void AccessDefinition::add_versions(const char* value, size_t size) {
  versions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:coprocess.AccessDefinition.versions)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AccessDefinition::versions() const {
  // @@protoc_insertion_point(field_list:coprocess.AccessDefinition.versions)
  return versions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AccessDefinition::mutable_versions() {
  // @@protoc_insertion_point(field_mutable_list:coprocess.AccessDefinition.versions)
  return &versions_;
}

// repeated .coprocess.AccessSpec allowed_urls = 4;
inline int AccessDefinition::allowed_urls_size() const {
  return allowed_urls_.size();
}
inline void AccessDefinition::clear_allowed_urls() {
  allowed_urls_.Clear();
}
inline ::coprocess::AccessSpec* AccessDefinition::mutable_allowed_urls(int index) {
  // @@protoc_insertion_point(field_mutable:coprocess.AccessDefinition.allowed_urls)
  return allowed_urls_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::coprocess::AccessSpec >*
AccessDefinition::mutable_allowed_urls() {
  // @@protoc_insertion_point(field_mutable_list:coprocess.AccessDefinition.allowed_urls)
  return &allowed_urls_;
}
inline const ::coprocess::AccessSpec& AccessDefinition::allowed_urls(int index) const {
  // @@protoc_insertion_point(field_get:coprocess.AccessDefinition.allowed_urls)
  return allowed_urls_.Get(index);
}
inline ::coprocess::AccessSpec* AccessDefinition::add_allowed_urls() {
  // @@protoc_insertion_point(field_add:coprocess.AccessDefinition.allowed_urls)
  return allowed_urls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::coprocess::AccessSpec >&
AccessDefinition::allowed_urls() const {
  // @@protoc_insertion_point(field_list:coprocess.AccessDefinition.allowed_urls)
  return allowed_urls_;
}

// -------------------------------------------------------------------

// BasicAuthData

// string password = 1;
inline void BasicAuthData::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BasicAuthData::password() const {
  // @@protoc_insertion_point(field_get:coprocess.BasicAuthData.password)
  return password_.GetNoArena();
}
inline void BasicAuthData::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:coprocess.BasicAuthData.password)
}
#if LANG_CXX11
inline void BasicAuthData::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:coprocess.BasicAuthData.password)
}
#endif
inline void BasicAuthData::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:coprocess.BasicAuthData.password)
}
inline void BasicAuthData::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:coprocess.BasicAuthData.password)
}
inline ::std::string* BasicAuthData::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:coprocess.BasicAuthData.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BasicAuthData::release_password() {
  // @@protoc_insertion_point(field_release:coprocess.BasicAuthData.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BasicAuthData::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:coprocess.BasicAuthData.password)
}

// string hash = 2;
inline void BasicAuthData::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BasicAuthData::hash() const {
  // @@protoc_insertion_point(field_get:coprocess.BasicAuthData.hash)
  return hash_.GetNoArena();
}
inline void BasicAuthData::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:coprocess.BasicAuthData.hash)
}
#if LANG_CXX11
inline void BasicAuthData::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:coprocess.BasicAuthData.hash)
}
#endif
inline void BasicAuthData::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:coprocess.BasicAuthData.hash)
}
inline void BasicAuthData::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:coprocess.BasicAuthData.hash)
}
inline ::std::string* BasicAuthData::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:coprocess.BasicAuthData.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BasicAuthData::release_hash() {
  // @@protoc_insertion_point(field_release:coprocess.BasicAuthData.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BasicAuthData::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:coprocess.BasicAuthData.hash)
}

// -------------------------------------------------------------------

// JWTData

// string secret = 1;
inline void JWTData::clear_secret() {
  secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JWTData::secret() const {
  // @@protoc_insertion_point(field_get:coprocess.JWTData.secret)
  return secret_.GetNoArena();
}
inline void JWTData::set_secret(const ::std::string& value) {
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:coprocess.JWTData.secret)
}
#if LANG_CXX11
inline void JWTData::set_secret(::std::string&& value) {
  
  secret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:coprocess.JWTData.secret)
}
#endif
inline void JWTData::set_secret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:coprocess.JWTData.secret)
}
inline void JWTData::set_secret(const char* value, size_t size) {
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:coprocess.JWTData.secret)
}
inline ::std::string* JWTData::mutable_secret() {
  
  // @@protoc_insertion_point(field_mutable:coprocess.JWTData.secret)
  return secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JWTData::release_secret() {
  // @@protoc_insertion_point(field_release:coprocess.JWTData.secret)
  
  return secret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JWTData::set_allocated_secret(::std::string* secret) {
  if (secret != NULL) {
    
  } else {
    
  }
  secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secret);
  // @@protoc_insertion_point(field_set_allocated:coprocess.JWTData.secret)
}

// -------------------------------------------------------------------

// Monitor

// repeated double trigger_limits = 1;
inline int Monitor::trigger_limits_size() const {
  return trigger_limits_.size();
}
inline void Monitor::clear_trigger_limits() {
  trigger_limits_.Clear();
}
inline double Monitor::trigger_limits(int index) const {
  // @@protoc_insertion_point(field_get:coprocess.Monitor.trigger_limits)
  return trigger_limits_.Get(index);
}
inline void Monitor::set_trigger_limits(int index, double value) {
  trigger_limits_.Set(index, value);
  // @@protoc_insertion_point(field_set:coprocess.Monitor.trigger_limits)
}
inline void Monitor::add_trigger_limits(double value) {
  trigger_limits_.Add(value);
  // @@protoc_insertion_point(field_add:coprocess.Monitor.trigger_limits)
}
inline const ::google::protobuf::RepeatedField< double >&
Monitor::trigger_limits() const {
  // @@protoc_insertion_point(field_list:coprocess.Monitor.trigger_limits)
  return trigger_limits_;
}
inline ::google::protobuf::RepeatedField< double >*
Monitor::mutable_trigger_limits() {
  // @@protoc_insertion_point(field_mutable_list:coprocess.Monitor.trigger_limits)
  return &trigger_limits_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SessionState

// int64 last_check = 1;
inline void SessionState::clear_last_check() {
  last_check_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SessionState::last_check() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.last_check)
  return last_check_;
}
inline void SessionState::set_last_check(::google::protobuf::int64 value) {
  
  last_check_ = value;
  // @@protoc_insertion_point(field_set:coprocess.SessionState.last_check)
}

// double allowance = 2;
inline void SessionState::clear_allowance() {
  allowance_ = 0;
}
inline double SessionState::allowance() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.allowance)
  return allowance_;
}
inline void SessionState::set_allowance(double value) {
  
  allowance_ = value;
  // @@protoc_insertion_point(field_set:coprocess.SessionState.allowance)
}

// double rate = 3;
inline void SessionState::clear_rate() {
  rate_ = 0;
}
inline double SessionState::rate() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.rate)
  return rate_;
}
inline void SessionState::set_rate(double value) {
  
  rate_ = value;
  // @@protoc_insertion_point(field_set:coprocess.SessionState.rate)
}

// double per = 4;
inline void SessionState::clear_per() {
  per_ = 0;
}
inline double SessionState::per() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.per)
  return per_;
}
inline void SessionState::set_per(double value) {
  
  per_ = value;
  // @@protoc_insertion_point(field_set:coprocess.SessionState.per)
}

// int64 expires = 5;
inline void SessionState::clear_expires() {
  expires_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SessionState::expires() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.expires)
  return expires_;
}
inline void SessionState::set_expires(::google::protobuf::int64 value) {
  
  expires_ = value;
  // @@protoc_insertion_point(field_set:coprocess.SessionState.expires)
}

// int64 quota_max = 6;
inline void SessionState::clear_quota_max() {
  quota_max_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SessionState::quota_max() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.quota_max)
  return quota_max_;
}
inline void SessionState::set_quota_max(::google::protobuf::int64 value) {
  
  quota_max_ = value;
  // @@protoc_insertion_point(field_set:coprocess.SessionState.quota_max)
}

// int64 quota_renews = 7;
inline void SessionState::clear_quota_renews() {
  quota_renews_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SessionState::quota_renews() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.quota_renews)
  return quota_renews_;
}
inline void SessionState::set_quota_renews(::google::protobuf::int64 value) {
  
  quota_renews_ = value;
  // @@protoc_insertion_point(field_set:coprocess.SessionState.quota_renews)
}

// int64 quota_remaining = 8;
inline void SessionState::clear_quota_remaining() {
  quota_remaining_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SessionState::quota_remaining() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.quota_remaining)
  return quota_remaining_;
}
inline void SessionState::set_quota_remaining(::google::protobuf::int64 value) {
  
  quota_remaining_ = value;
  // @@protoc_insertion_point(field_set:coprocess.SessionState.quota_remaining)
}

// int64 quota_renewal_rate = 9;
inline void SessionState::clear_quota_renewal_rate() {
  quota_renewal_rate_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SessionState::quota_renewal_rate() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.quota_renewal_rate)
  return quota_renewal_rate_;
}
inline void SessionState::set_quota_renewal_rate(::google::protobuf::int64 value) {
  
  quota_renewal_rate_ = value;
  // @@protoc_insertion_point(field_set:coprocess.SessionState.quota_renewal_rate)
}

// map<string, .coprocess.AccessDefinition> access_rights = 10;
inline int SessionState::access_rights_size() const {
  return access_rights_.size();
}
inline void SessionState::clear_access_rights() {
  access_rights_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::coprocess::AccessDefinition >&
SessionState::access_rights() const {
  // @@protoc_insertion_point(field_map:coprocess.SessionState.access_rights)
  return access_rights_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::coprocess::AccessDefinition >*
SessionState::mutable_access_rights() {
  // @@protoc_insertion_point(field_mutable_map:coprocess.SessionState.access_rights)
  return access_rights_.MutableMap();
}

// string org_id = 11;
inline void SessionState::clear_org_id() {
  org_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SessionState::org_id() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.org_id)
  return org_id_.GetNoArena();
}
inline void SessionState::set_org_id(const ::std::string& value) {
  
  org_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:coprocess.SessionState.org_id)
}
#if LANG_CXX11
inline void SessionState::set_org_id(::std::string&& value) {
  
  org_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:coprocess.SessionState.org_id)
}
#endif
inline void SessionState::set_org_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  org_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:coprocess.SessionState.org_id)
}
inline void SessionState::set_org_id(const char* value, size_t size) {
  
  org_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:coprocess.SessionState.org_id)
}
inline ::std::string* SessionState::mutable_org_id() {
  
  // @@protoc_insertion_point(field_mutable:coprocess.SessionState.org_id)
  return org_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionState::release_org_id() {
  // @@protoc_insertion_point(field_release:coprocess.SessionState.org_id)
  
  return org_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionState::set_allocated_org_id(::std::string* org_id) {
  if (org_id != NULL) {
    
  } else {
    
  }
  org_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), org_id);
  // @@protoc_insertion_point(field_set_allocated:coprocess.SessionState.org_id)
}

// string oauth_client_id = 12;
inline void SessionState::clear_oauth_client_id() {
  oauth_client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SessionState::oauth_client_id() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.oauth_client_id)
  return oauth_client_id_.GetNoArena();
}
inline void SessionState::set_oauth_client_id(const ::std::string& value) {
  
  oauth_client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:coprocess.SessionState.oauth_client_id)
}
#if LANG_CXX11
inline void SessionState::set_oauth_client_id(::std::string&& value) {
  
  oauth_client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:coprocess.SessionState.oauth_client_id)
}
#endif
inline void SessionState::set_oauth_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  oauth_client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:coprocess.SessionState.oauth_client_id)
}
inline void SessionState::set_oauth_client_id(const char* value, size_t size) {
  
  oauth_client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:coprocess.SessionState.oauth_client_id)
}
inline ::std::string* SessionState::mutable_oauth_client_id() {
  
  // @@protoc_insertion_point(field_mutable:coprocess.SessionState.oauth_client_id)
  return oauth_client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionState::release_oauth_client_id() {
  // @@protoc_insertion_point(field_release:coprocess.SessionState.oauth_client_id)
  
  return oauth_client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionState::set_allocated_oauth_client_id(::std::string* oauth_client_id) {
  if (oauth_client_id != NULL) {
    
  } else {
    
  }
  oauth_client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oauth_client_id);
  // @@protoc_insertion_point(field_set_allocated:coprocess.SessionState.oauth_client_id)
}

// map<string, string> oauth_keys = 13;
inline int SessionState::oauth_keys_size() const {
  return oauth_keys_.size();
}
inline void SessionState::clear_oauth_keys() {
  oauth_keys_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
SessionState::oauth_keys() const {
  // @@protoc_insertion_point(field_map:coprocess.SessionState.oauth_keys)
  return oauth_keys_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
SessionState::mutable_oauth_keys() {
  // @@protoc_insertion_point(field_mutable_map:coprocess.SessionState.oauth_keys)
  return oauth_keys_.MutableMap();
}

// .coprocess.BasicAuthData basic_auth_data = 14;
inline bool SessionState::has_basic_auth_data() const {
  return this != internal_default_instance() && basic_auth_data_ != NULL;
}
inline void SessionState::clear_basic_auth_data() {
  if (GetArenaNoVirtual() == NULL && basic_auth_data_ != NULL) {
    delete basic_auth_data_;
  }
  basic_auth_data_ = NULL;
}
inline const ::coprocess::BasicAuthData& SessionState::_internal_basic_auth_data() const {
  return *basic_auth_data_;
}
inline const ::coprocess::BasicAuthData& SessionState::basic_auth_data() const {
  const ::coprocess::BasicAuthData* p = basic_auth_data_;
  // @@protoc_insertion_point(field_get:coprocess.SessionState.basic_auth_data)
  return p != NULL ? *p : *reinterpret_cast<const ::coprocess::BasicAuthData*>(
      &::coprocess::_BasicAuthData_default_instance_);
}
inline ::coprocess::BasicAuthData* SessionState::release_basic_auth_data() {
  // @@protoc_insertion_point(field_release:coprocess.SessionState.basic_auth_data)
  
  ::coprocess::BasicAuthData* temp = basic_auth_data_;
  basic_auth_data_ = NULL;
  return temp;
}
inline ::coprocess::BasicAuthData* SessionState::mutable_basic_auth_data() {
  
  if (basic_auth_data_ == NULL) {
    auto* p = CreateMaybeMessage<::coprocess::BasicAuthData>(GetArenaNoVirtual());
    basic_auth_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:coprocess.SessionState.basic_auth_data)
  return basic_auth_data_;
}
inline void SessionState::set_allocated_basic_auth_data(::coprocess::BasicAuthData* basic_auth_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete basic_auth_data_;
  }
  if (basic_auth_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      basic_auth_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, basic_auth_data, submessage_arena);
    }
    
  } else {
    
  }
  basic_auth_data_ = basic_auth_data;
  // @@protoc_insertion_point(field_set_allocated:coprocess.SessionState.basic_auth_data)
}

// .coprocess.JWTData jwt_data = 15;
inline bool SessionState::has_jwt_data() const {
  return this != internal_default_instance() && jwt_data_ != NULL;
}
inline void SessionState::clear_jwt_data() {
  if (GetArenaNoVirtual() == NULL && jwt_data_ != NULL) {
    delete jwt_data_;
  }
  jwt_data_ = NULL;
}
inline const ::coprocess::JWTData& SessionState::_internal_jwt_data() const {
  return *jwt_data_;
}
inline const ::coprocess::JWTData& SessionState::jwt_data() const {
  const ::coprocess::JWTData* p = jwt_data_;
  // @@protoc_insertion_point(field_get:coprocess.SessionState.jwt_data)
  return p != NULL ? *p : *reinterpret_cast<const ::coprocess::JWTData*>(
      &::coprocess::_JWTData_default_instance_);
}
inline ::coprocess::JWTData* SessionState::release_jwt_data() {
  // @@protoc_insertion_point(field_release:coprocess.SessionState.jwt_data)
  
  ::coprocess::JWTData* temp = jwt_data_;
  jwt_data_ = NULL;
  return temp;
}
inline ::coprocess::JWTData* SessionState::mutable_jwt_data() {
  
  if (jwt_data_ == NULL) {
    auto* p = CreateMaybeMessage<::coprocess::JWTData>(GetArenaNoVirtual());
    jwt_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:coprocess.SessionState.jwt_data)
  return jwt_data_;
}
inline void SessionState::set_allocated_jwt_data(::coprocess::JWTData* jwt_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete jwt_data_;
  }
  if (jwt_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      jwt_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, jwt_data, submessage_arena);
    }
    
  } else {
    
  }
  jwt_data_ = jwt_data;
  // @@protoc_insertion_point(field_set_allocated:coprocess.SessionState.jwt_data)
}

// bool hmac_enabled = 16;
inline void SessionState::clear_hmac_enabled() {
  hmac_enabled_ = false;
}
inline bool SessionState::hmac_enabled() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.hmac_enabled)
  return hmac_enabled_;
}
inline void SessionState::set_hmac_enabled(bool value) {
  
  hmac_enabled_ = value;
  // @@protoc_insertion_point(field_set:coprocess.SessionState.hmac_enabled)
}

// string hmac_secret = 17;
inline void SessionState::clear_hmac_secret() {
  hmac_secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SessionState::hmac_secret() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.hmac_secret)
  return hmac_secret_.GetNoArena();
}
inline void SessionState::set_hmac_secret(const ::std::string& value) {
  
  hmac_secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:coprocess.SessionState.hmac_secret)
}
#if LANG_CXX11
inline void SessionState::set_hmac_secret(::std::string&& value) {
  
  hmac_secret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:coprocess.SessionState.hmac_secret)
}
#endif
inline void SessionState::set_hmac_secret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hmac_secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:coprocess.SessionState.hmac_secret)
}
inline void SessionState::set_hmac_secret(const char* value, size_t size) {
  
  hmac_secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:coprocess.SessionState.hmac_secret)
}
inline ::std::string* SessionState::mutable_hmac_secret() {
  
  // @@protoc_insertion_point(field_mutable:coprocess.SessionState.hmac_secret)
  return hmac_secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionState::release_hmac_secret() {
  // @@protoc_insertion_point(field_release:coprocess.SessionState.hmac_secret)
  
  return hmac_secret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionState::set_allocated_hmac_secret(::std::string* hmac_secret) {
  if (hmac_secret != NULL) {
    
  } else {
    
  }
  hmac_secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hmac_secret);
  // @@protoc_insertion_point(field_set_allocated:coprocess.SessionState.hmac_secret)
}

// bool is_inactive = 18;
inline void SessionState::clear_is_inactive() {
  is_inactive_ = false;
}
inline bool SessionState::is_inactive() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.is_inactive)
  return is_inactive_;
}
inline void SessionState::set_is_inactive(bool value) {
  
  is_inactive_ = value;
  // @@protoc_insertion_point(field_set:coprocess.SessionState.is_inactive)
}

// string apply_policy_id = 19;
inline void SessionState::clear_apply_policy_id() {
  apply_policy_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SessionState::apply_policy_id() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.apply_policy_id)
  return apply_policy_id_.GetNoArena();
}
inline void SessionState::set_apply_policy_id(const ::std::string& value) {
  
  apply_policy_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:coprocess.SessionState.apply_policy_id)
}
#if LANG_CXX11
inline void SessionState::set_apply_policy_id(::std::string&& value) {
  
  apply_policy_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:coprocess.SessionState.apply_policy_id)
}
#endif
inline void SessionState::set_apply_policy_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  apply_policy_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:coprocess.SessionState.apply_policy_id)
}
inline void SessionState::set_apply_policy_id(const char* value, size_t size) {
  
  apply_policy_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:coprocess.SessionState.apply_policy_id)
}
inline ::std::string* SessionState::mutable_apply_policy_id() {
  
  // @@protoc_insertion_point(field_mutable:coprocess.SessionState.apply_policy_id)
  return apply_policy_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionState::release_apply_policy_id() {
  // @@protoc_insertion_point(field_release:coprocess.SessionState.apply_policy_id)
  
  return apply_policy_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionState::set_allocated_apply_policy_id(::std::string* apply_policy_id) {
  if (apply_policy_id != NULL) {
    
  } else {
    
  }
  apply_policy_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), apply_policy_id);
  // @@protoc_insertion_point(field_set_allocated:coprocess.SessionState.apply_policy_id)
}

// int64 data_expires = 20;
inline void SessionState::clear_data_expires() {
  data_expires_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SessionState::data_expires() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.data_expires)
  return data_expires_;
}
inline void SessionState::set_data_expires(::google::protobuf::int64 value) {
  
  data_expires_ = value;
  // @@protoc_insertion_point(field_set:coprocess.SessionState.data_expires)
}

// .coprocess.Monitor monitor = 21;
inline bool SessionState::has_monitor() const {
  return this != internal_default_instance() && monitor_ != NULL;
}
inline void SessionState::clear_monitor() {
  if (GetArenaNoVirtual() == NULL && monitor_ != NULL) {
    delete monitor_;
  }
  monitor_ = NULL;
}
inline const ::coprocess::Monitor& SessionState::_internal_monitor() const {
  return *monitor_;
}
inline const ::coprocess::Monitor& SessionState::monitor() const {
  const ::coprocess::Monitor* p = monitor_;
  // @@protoc_insertion_point(field_get:coprocess.SessionState.monitor)
  return p != NULL ? *p : *reinterpret_cast<const ::coprocess::Monitor*>(
      &::coprocess::_Monitor_default_instance_);
}
inline ::coprocess::Monitor* SessionState::release_monitor() {
  // @@protoc_insertion_point(field_release:coprocess.SessionState.monitor)
  
  ::coprocess::Monitor* temp = monitor_;
  monitor_ = NULL;
  return temp;
}
inline ::coprocess::Monitor* SessionState::mutable_monitor() {
  
  if (monitor_ == NULL) {
    auto* p = CreateMaybeMessage<::coprocess::Monitor>(GetArenaNoVirtual());
    monitor_ = p;
  }
  // @@protoc_insertion_point(field_mutable:coprocess.SessionState.monitor)
  return monitor_;
}
inline void SessionState::set_allocated_monitor(::coprocess::Monitor* monitor) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete monitor_;
  }
  if (monitor) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      monitor = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, monitor, submessage_arena);
    }
    
  } else {
    
  }
  monitor_ = monitor;
  // @@protoc_insertion_point(field_set_allocated:coprocess.SessionState.monitor)
}

// bool enable_detailed_recording = 22;
inline void SessionState::clear_enable_detailed_recording() {
  enable_detailed_recording_ = false;
}
inline bool SessionState::enable_detailed_recording() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.enable_detailed_recording)
  return enable_detailed_recording_;
}
inline void SessionState::set_enable_detailed_recording(bool value) {
  
  enable_detailed_recording_ = value;
  // @@protoc_insertion_point(field_set:coprocess.SessionState.enable_detailed_recording)
}

// string metadata = 23;
inline void SessionState::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SessionState::metadata() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.metadata)
  return metadata_.GetNoArena();
}
inline void SessionState::set_metadata(const ::std::string& value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:coprocess.SessionState.metadata)
}
#if LANG_CXX11
inline void SessionState::set_metadata(::std::string&& value) {
  
  metadata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:coprocess.SessionState.metadata)
}
#endif
inline void SessionState::set_metadata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:coprocess.SessionState.metadata)
}
inline void SessionState::set_metadata(const char* value, size_t size) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:coprocess.SessionState.metadata)
}
inline ::std::string* SessionState::mutable_metadata() {
  
  // @@protoc_insertion_point(field_mutable:coprocess.SessionState.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionState::release_metadata() {
  // @@protoc_insertion_point(field_release:coprocess.SessionState.metadata)
  
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionState::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    
  } else {
    
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:coprocess.SessionState.metadata)
}

// repeated string tags = 24;
inline int SessionState::tags_size() const {
  return tags_.size();
}
inline void SessionState::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& SessionState::tags(int index) const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.tags)
  return tags_.Get(index);
}
inline ::std::string* SessionState::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:coprocess.SessionState.tags)
  return tags_.Mutable(index);
}
inline void SessionState::set_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:coprocess.SessionState.tags)
  tags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SessionState::set_tags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:coprocess.SessionState.tags)
  tags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SessionState::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:coprocess.SessionState.tags)
}
inline void SessionState::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:coprocess.SessionState.tags)
}
inline ::std::string* SessionState::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:coprocess.SessionState.tags)
  return tags_.Add();
}
inline void SessionState::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:coprocess.SessionState.tags)
}
#if LANG_CXX11
inline void SessionState::add_tags(::std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:coprocess.SessionState.tags)
}
#endif
inline void SessionState::add_tags(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:coprocess.SessionState.tags)
}
inline void SessionState::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:coprocess.SessionState.tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SessionState::tags() const {
  // @@protoc_insertion_point(field_list:coprocess.SessionState.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SessionState::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:coprocess.SessionState.tags)
  return &tags_;
}

// string alias = 25;
inline void SessionState::clear_alias() {
  alias_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SessionState::alias() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.alias)
  return alias_.GetNoArena();
}
inline void SessionState::set_alias(const ::std::string& value) {
  
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:coprocess.SessionState.alias)
}
#if LANG_CXX11
inline void SessionState::set_alias(::std::string&& value) {
  
  alias_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:coprocess.SessionState.alias)
}
#endif
inline void SessionState::set_alias(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:coprocess.SessionState.alias)
}
inline void SessionState::set_alias(const char* value, size_t size) {
  
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:coprocess.SessionState.alias)
}
inline ::std::string* SessionState::mutable_alias() {
  
  // @@protoc_insertion_point(field_mutable:coprocess.SessionState.alias)
  return alias_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionState::release_alias() {
  // @@protoc_insertion_point(field_release:coprocess.SessionState.alias)
  
  return alias_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionState::set_allocated_alias(::std::string* alias) {
  if (alias != NULL) {
    
  } else {
    
  }
  alias_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), alias);
  // @@protoc_insertion_point(field_set_allocated:coprocess.SessionState.alias)
}

// string last_updated = 26;
inline void SessionState::clear_last_updated() {
  last_updated_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SessionState::last_updated() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.last_updated)
  return last_updated_.GetNoArena();
}
inline void SessionState::set_last_updated(const ::std::string& value) {
  
  last_updated_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:coprocess.SessionState.last_updated)
}
#if LANG_CXX11
inline void SessionState::set_last_updated(::std::string&& value) {
  
  last_updated_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:coprocess.SessionState.last_updated)
}
#endif
inline void SessionState::set_last_updated(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  last_updated_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:coprocess.SessionState.last_updated)
}
inline void SessionState::set_last_updated(const char* value, size_t size) {
  
  last_updated_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:coprocess.SessionState.last_updated)
}
inline ::std::string* SessionState::mutable_last_updated() {
  
  // @@protoc_insertion_point(field_mutable:coprocess.SessionState.last_updated)
  return last_updated_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionState::release_last_updated() {
  // @@protoc_insertion_point(field_release:coprocess.SessionState.last_updated)
  
  return last_updated_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionState::set_allocated_last_updated(::std::string* last_updated) {
  if (last_updated != NULL) {
    
  } else {
    
  }
  last_updated_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_updated);
  // @@protoc_insertion_point(field_set_allocated:coprocess.SessionState.last_updated)
}

// int64 id_extractor_deadline = 27;
inline void SessionState::clear_id_extractor_deadline() {
  id_extractor_deadline_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SessionState::id_extractor_deadline() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.id_extractor_deadline)
  return id_extractor_deadline_;
}
inline void SessionState::set_id_extractor_deadline(::google::protobuf::int64 value) {
  
  id_extractor_deadline_ = value;
  // @@protoc_insertion_point(field_set:coprocess.SessionState.id_extractor_deadline)
}

// int64 session_lifetime = 28;
inline void SessionState::clear_session_lifetime() {
  session_lifetime_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SessionState::session_lifetime() const {
  // @@protoc_insertion_point(field_get:coprocess.SessionState.session_lifetime)
  return session_lifetime_;
}
inline void SessionState::set_session_lifetime(::google::protobuf::int64 value) {
  
  session_lifetime_ = value;
  // @@protoc_insertion_point(field_set:coprocess.SessionState.session_lifetime)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace coprocess

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_coprocess_5fsession_5fstate_2eproto
